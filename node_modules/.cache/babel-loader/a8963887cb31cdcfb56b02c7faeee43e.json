{"remainingRequest":"E:\\自己的项目\\three_test\\node_modules\\babel-loader\\lib\\index.js!E:\\自己的项目\\three_test\\src\\assets\\jsm\\loaders\\STLLoader.js","dependencies":[{"path":"E:\\自己的项目\\three_test\\src\\assets\\jsm\\loaders\\STLLoader.js","mtime":1581177211273},{"path":"E:\\自己的项目\\three_test\\node_modules\\@vue\\cli-plugin-babel\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLnNsaWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZGF0YS12aWV3IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWZsb2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQzMi1hcnJheSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5tYXAiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZXZlcnNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb21lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tbG9jYWxlLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZyI7CgovKioKICogQGF1dGhvciBhbGVlcGVyIC8gaHR0cDovL2FkYW1sZWVwZXIuY29tLwogKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tLwogKiBAYXV0aG9yIGdlcm8zIC8gaHR0cHM6Ly9naXRodWIuY29tL2dlcm8zCiAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3CiAqIEBhdXRob3IgbmV2ZXJob29kMzExIC8gaHR0cHM6Ly9naXRodWIuY29tL25ldmVyaG9vZDMxMQogKgogKiBEZXNjcmlwdGlvbjogQSBUSFJFRSBsb2FkZXIgZm9yIFNUTCBBU0NJSSBmaWxlcywgYXMgY3JlYXRlZCBieSBTb2xpZHdvcmtzIGFuZCBvdGhlciBDQUQgcHJvZ3JhbXMuCiAqCiAqIFN1cHBvcnRzIGJvdGggYmluYXJ5IGFuZCBBU0NJSSBlbmNvZGVkIGZpbGVzLCB3aXRoIGF1dG9tYXRpYyBkZXRlY3Rpb24gb2YgdHlwZS4KICoKICogVGhlIGxvYWRlciByZXR1cm5zIGEgbm9uLWluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5LgogKgogKiBMaW1pdGF0aW9uczoKICogIEJpbmFyeSBkZWNvZGluZyBzdXBwb3J0cyAiTWFnaWNzIiBjb2xvciBmb3JtYXQgKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU1RMXyhmaWxlX2Zvcm1hdCkjQ29sb3JfaW5fYmluYXJ5X1NUTCkuCiAqICBUaGVyZSBpcyBwZXJoYXBzIHNvbWUgcXVlc3Rpb24gYXMgdG8gaG93IHZhbGlkIGl0IGlzIHRvIGFsd2F5cyBhc3N1bWUgbGl0dGxlLWVuZGlhbi1uZXNzLgogKiAgQVNDSUkgZGVjb2RpbmcgYXNzdW1lcyBmaWxlIGlzIFVURi04LgogKgogKiBVc2FnZToKICogIHZhciBsb2FkZXIgPSBuZXcgU1RMTG9hZGVyKCk7CiAqICBsb2FkZXIubG9hZCggJy4vbW9kZWxzL3N0bC9zbG90dGVkX2Rpc2suc3RsJywgZnVuY3Rpb24gKCBnZW9tZXRyeSApIHsKICogICAgc2NlbmUuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnkgKSApOwogKiAgfSk7CiAqCiAqIEZvciBiaW5hcnkgU1RMcyBnZW9tZXRyeSBtaWdodCBjb250YWluIGNvbG9ycyBmb3IgdmVydGljZXMuIFRvIHVzZSBpdDoKICogIC8vIHVzZSB0aGUgc2FtZSBjb2RlIHRvIGxvYWQgU1RMIGFzIGFib3ZlCiAqICBpZiAoZ2VvbWV0cnkuaGFzQ29sb3JzKSB7CiAqICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHsgb3BhY2l0eTogZ2VvbWV0cnkuYWxwaGEsIHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzIH0pOwogKiAgfSBlbHNlIHsgLi4uLiB9CiAqICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTsKICoKICogRm9yIEFTQ0lJIFNUTHMgY29udGFpbmluZyBtdWx0aXBsZSBzb2xpZHMsIGVhY2ggc29saWQgaXMgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgZ3JvdXAuCiAqIEdyb3VwcyBjYW4gYmUgdXNlZCB0byBhc3NpZ24gYSBkaWZmZXJlbnQgY29sb3IgYnkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgbWF0ZXJpYWxzIHdpdGggdGhlIHNhbWUgbGVuZ3RoIG9mCiAqIGdlb21ldHJ5Lmdyb3VwcyBhbmQgcGFzc2luZyBpdCB0byB0aGUgTWVzaCBjb25zdHJ1Y3RvcjoKICoKICogdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7CiAqCiAqIEZvciBleGFtcGxlOgogKgogKiAgdmFyIG1hdGVyaWFscyA9IFtdOwogKiAgdmFyIG5HZW9tZXRyeUdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGg7CiAqCiAqICB2YXIgY29sb3JNYXAgPSAuLi47IC8vIFNvbWUgbG9naWMgdG8gaW5kZXggY29sb3JzLgogKgogKiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuR2VvbWV0cnlHcm91cHM7IGkrKykgewogKgogKgkJdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHsKICoJCQljb2xvcjogY29sb3JNYXBbaV0sCiAqCQkJd2lyZWZyYW1lOiBmYWxzZQogKgkJfSk7CiAqCiAqICB9CiAqCiAqICBtYXRlcmlhbHMucHVzaChtYXRlcmlhbCk7CiAqICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbHMpOwogKi8KaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgRmlsZUxvYWRlciwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgTG9hZGVyLCBMb2FkZXJVdGlscywgVmVjdG9yMyB9IGZyb20gIi4uLy4uL2pzL3RocmVlLm1vZHVsZS5qcyI7Cgp2YXIgU1RMTG9hZGVyID0gZnVuY3Rpb24gU1RMTG9hZGVyKG1hbmFnZXIpIHsKICBMb2FkZXIuY2FsbCh0aGlzLCBtYW5hZ2VyKTsKfTsKClNUTExvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoTG9hZGVyLnByb3RvdHlwZSksIHsKICBjb25zdHJ1Y3RvcjogU1RMTG9hZGVyLAogIGxvYWQ6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHsKICAgIHZhciBzY29wZSA9IHRoaXM7CiAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoc2NvcGUubWFuYWdlcik7CiAgICBsb2FkZXIuc2V0UGF0aChzY29wZS5wYXRoKTsKICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7CiAgICBsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgb25Mb2FkKHNjb3BlLnBhcnNlKHRleHQpKTsKICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7CiAgICAgICAgaWYgKG9uRXJyb3IpIHsKICAgICAgICAgIG9uRXJyb3IoZXhjZXB0aW9uKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpOwogIH0sCiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGRhdGEpIHsKICAgIGZ1bmN0aW9uIGlzQmluYXJ5KGRhdGEpIHsKICAgICAgdmFyIGV4cGVjdCwgZmFjZV9zaXplLCBuX2ZhY2VzLCByZWFkZXI7CiAgICAgIHJlYWRlciA9IG5ldyBEYXRhVmlldyhkYXRhKTsKICAgICAgZmFjZV9zaXplID0gMzIgLyA4ICogMyArIDMyIC8gOCAqIDMgKiAzICsgMTYgLyA4OwogICAgICBuX2ZhY2VzID0gcmVhZGVyLmdldFVpbnQzMig4MCwgdHJ1ZSk7CiAgICAgIGV4cGVjdCA9IDgwICsgMzIgLyA4ICsgbl9mYWNlcyAqIGZhY2Vfc2l6ZTsKCiAgICAgIGlmIChleHBlY3QgPT09IHJlYWRlci5ieXRlTGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0gLy8gQW4gQVNDSUkgU1RMIGRhdGEgbXVzdCBiZWdpbiB3aXRoICdzb2xpZCAnIGFzIHRoZSBmaXJzdCBzaXggYnl0ZXMuCiAgICAgIC8vIEhvd2V2ZXIsIEFTQ0lJIFNUTHMgbGFja2luZyB0aGUgU1BBQ0UgYWZ0ZXIgdGhlICdkJyBhcmUga25vd24gdG8gYmUKICAgICAgLy8gcGxlbnRpZnVsLiAgU28sIGNoZWNrIHRoZSBmaXJzdCA1IGJ5dGVzIGZvciAnc29saWQnLgogICAgICAvLyBTZXZlcmFsIGVuY29kaW5ncywgc3VjaCBhcyBVVEYtOCwgcHJlY2VkZSB0aGUgdGV4dCB3aXRoIHVwIHRvIDUgYnl0ZXM6CiAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0J5dGVfb3JkZXJfbWFyayNCeXRlX29yZGVyX21hcmtzX2J5X2VuY29kaW5nCiAgICAgIC8vIFNlYXJjaCBmb3IgInNvbGlkIiB0byBzdGFydCBhbnl3aGVyZSBhZnRlciB0aG9zZSBwcmVmaXhlcy4KICAgICAgLy8gVVMtQVNDSUkgb3JkaW5hbCB2YWx1ZXMgZm9yICdzJywgJ28nLCAnbCcsICdpJywgJ2QnCgoKICAgICAgdmFyIHNvbGlkID0gWzExNSwgMTExLCAxMDgsIDEwNSwgMTAwXTsKCiAgICAgIGZvciAodmFyIG9mZiA9IDA7IG9mZiA8IDU7IG9mZisrKSB7CiAgICAgICAgLy8gSWYgInNvbGlkIiB0ZXh0IGlzIG1hdGNoZWQgdG8gdGhlIGN1cnJlbnQgb2Zmc2V0LCBkZWNsYXJlIGl0IHRvIGJlIGFuIEFTQ0lJIFNUTC4KICAgICAgICBpZiAobWF0Y2hEYXRhVmlld0F0KHNvbGlkLCByZWFkZXIsIG9mZikpIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBDb3VsZG4ndCBmaW5kICJzb2xpZCIgdGV4dCBhdCB0aGUgYmVnaW5uaW5nOyBpdCBpcyBiaW5hcnkgU1RMLgoKCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIG1hdGNoRGF0YVZpZXdBdChxdWVyeSwgcmVhZGVyLCBvZmZzZXQpIHsKICAgICAgLy8gQ2hlY2sgaWYgZWFjaCBieXRlIGluIHF1ZXJ5IG1hdGNoZXMgdGhlIGNvcnJlc3BvbmRpbmcgYnl0ZSBmcm9tIHRoZSBjdXJyZW50IG9mZnNldAogICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBxdWVyeS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7CiAgICAgICAgaWYgKHF1ZXJ5W2ldICE9PSByZWFkZXIuZ2V0VWludDgob2Zmc2V0ICsgaSwgZmFsc2UpKSByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQoKICAgIGZ1bmN0aW9uIHBhcnNlQmluYXJ5KGRhdGEpIHsKICAgICAgdmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyhkYXRhKTsKICAgICAgdmFyIGZhY2VzID0gcmVhZGVyLmdldFVpbnQzMig4MCwgdHJ1ZSk7CiAgICAgIHZhciByLAogICAgICAgICAgZywKICAgICAgICAgIGIsCiAgICAgICAgICBoYXNDb2xvcnMgPSBmYWxzZSwKICAgICAgICAgIGNvbG9yczsKICAgICAgdmFyIGRlZmF1bHRSLCBkZWZhdWx0RywgZGVmYXVsdEIsIGFscGhhOyAvLyBwcm9jZXNzIFNUTCBoZWFkZXIKICAgICAgLy8gY2hlY2sgZm9yIGRlZmF1bHQgY29sb3IgaW4gaGVhZGVyICgiQ09MT1I9cmdiYSIgc2VxdWVuY2UpLgoKICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IDgwIC0gMTA7IGluZGV4KyspIHsKICAgICAgICBpZiAocmVhZGVyLmdldFVpbnQzMihpbmRleCwgZmFsc2UpID09IDB4NDM0RjRDNEYKICAgICAgICAvKkNPTE8qLwogICAgICAgICYmIHJlYWRlci5nZXRVaW50OChpbmRleCArIDQpID09IDB4NTIKICAgICAgICAvKidSJyovCiAgICAgICAgJiYgcmVhZGVyLmdldFVpbnQ4KGluZGV4ICsgNSkgPT0gMHgzRAogICAgICAgIC8qJz0nKi8KICAgICAgICApIHsKICAgICAgICAgIGhhc0NvbG9ycyA9IHRydWU7CiAgICAgICAgICBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KGZhY2VzICogMyAqIDMpOwogICAgICAgICAgZGVmYXVsdFIgPSByZWFkZXIuZ2V0VWludDgoaW5kZXggKyA2KSAvIDI1NTsKICAgICAgICAgIGRlZmF1bHRHID0gcmVhZGVyLmdldFVpbnQ4KGluZGV4ICsgNykgLyAyNTU7CiAgICAgICAgICBkZWZhdWx0QiA9IHJlYWRlci5nZXRVaW50OChpbmRleCArIDgpIC8gMjU1OwogICAgICAgICAgYWxwaGEgPSByZWFkZXIuZ2V0VWludDgoaW5kZXggKyA5KSAvIDI1NTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBkYXRhT2Zmc2V0ID0gODQ7CiAgICAgIHZhciBmYWNlTGVuZ3RoID0gMTIgKiA0ICsgMjsKICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7CiAgICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoZmFjZXMgKiAzICogMyk7CiAgICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShmYWNlcyAqIDMgKiAzKTsKCiAgICAgIGZvciAodmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZXM7IGZhY2UrKykgewogICAgICAgIHZhciBzdGFydCA9IGRhdGFPZmZzZXQgKyBmYWNlICogZmFjZUxlbmd0aDsKICAgICAgICB2YXIgbm9ybWFsWCA9IHJlYWRlci5nZXRGbG9hdDMyKHN0YXJ0LCB0cnVlKTsKICAgICAgICB2YXIgbm9ybWFsWSA9IHJlYWRlci5nZXRGbG9hdDMyKHN0YXJ0ICsgNCwgdHJ1ZSk7CiAgICAgICAgdmFyIG5vcm1hbFogPSByZWFkZXIuZ2V0RmxvYXQzMihzdGFydCArIDgsIHRydWUpOwoKICAgICAgICBpZiAoaGFzQ29sb3JzKSB7CiAgICAgICAgICB2YXIgcGFja2VkQ29sb3IgPSByZWFkZXIuZ2V0VWludDE2KHN0YXJ0ICsgNDgsIHRydWUpOwoKICAgICAgICAgIGlmICgocGFja2VkQ29sb3IgJiAweDgwMDApID09PSAwKSB7CiAgICAgICAgICAgIC8vIGZhY2V0IGhhcyBpdHMgb3duIHVuaXF1ZSBjb2xvcgogICAgICAgICAgICByID0gKHBhY2tlZENvbG9yICYgMHgxRikgLyAzMTsKICAgICAgICAgICAgZyA9IChwYWNrZWRDb2xvciA+PiA1ICYgMHgxRikgLyAzMTsKICAgICAgICAgICAgYiA9IChwYWNrZWRDb2xvciA+PiAxMCAmIDB4MUYpIC8gMzE7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByID0gZGVmYXVsdFI7CiAgICAgICAgICAgIGcgPSBkZWZhdWx0RzsKICAgICAgICAgICAgYiA9IGRlZmF1bHRCOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gMzsgaSsrKSB7CiAgICAgICAgICB2YXIgdmVydGV4c3RhcnQgPSBzdGFydCArIGkgKiAxMjsKICAgICAgICAgIHZhciBjb21wb25lbnRJZHggPSBmYWNlICogMyAqIDMgKyAoaSAtIDEpICogMzsKICAgICAgICAgIHZlcnRpY2VzW2NvbXBvbmVudElkeF0gPSByZWFkZXIuZ2V0RmxvYXQzMih2ZXJ0ZXhzdGFydCwgdHJ1ZSk7CiAgICAgICAgICB2ZXJ0aWNlc1tjb21wb25lbnRJZHggKyAxXSA9IHJlYWRlci5nZXRGbG9hdDMyKHZlcnRleHN0YXJ0ICsgNCwgdHJ1ZSk7CiAgICAgICAgICB2ZXJ0aWNlc1tjb21wb25lbnRJZHggKyAyXSA9IHJlYWRlci5nZXRGbG9hdDMyKHZlcnRleHN0YXJ0ICsgOCwgdHJ1ZSk7CiAgICAgICAgICBub3JtYWxzW2NvbXBvbmVudElkeF0gPSBub3JtYWxYOwogICAgICAgICAgbm9ybWFsc1tjb21wb25lbnRJZHggKyAxXSA9IG5vcm1hbFk7CiAgICAgICAgICBub3JtYWxzW2NvbXBvbmVudElkeCArIDJdID0gbm9ybWFsWjsKCiAgICAgICAgICBpZiAoaGFzQ29sb3JzKSB7CiAgICAgICAgICAgIGNvbG9yc1tjb21wb25lbnRJZHhdID0gcjsKICAgICAgICAgICAgY29sb3JzW2NvbXBvbmVudElkeCArIDFdID0gZzsKICAgICAgICAgICAgY29sb3JzW2NvbXBvbmVudElkeCArIDJdID0gYjsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7CiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7CgogICAgICBpZiAoaGFzQ29sb3JzKSB7CiAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7CiAgICAgICAgZ2VvbWV0cnkuaGFzQ29sb3JzID0gdHJ1ZTsKICAgICAgICBnZW9tZXRyeS5hbHBoYSA9IGFscGhhOwogICAgICB9CgogICAgICByZXR1cm4gZ2VvbWV0cnk7CiAgICB9CgogICAgZnVuY3Rpb24gcGFyc2VBU0NJSShkYXRhKSB7CiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpOwogICAgICB2YXIgcGF0dGVyblNvbGlkID0gL3NvbGlkKFtcc1xTXSo/KWVuZHNvbGlkL2c7CiAgICAgIHZhciBwYXR0ZXJuRmFjZSA9IC9mYWNldChbXHNcU10qPyllbmRmYWNldC9nOwogICAgICB2YXIgZmFjZUNvdW50ZXIgPSAwOwogICAgICB2YXIgcGF0dGVybkZsb2F0ID0gL1tcc10rKFsrLV0/KD86XGQqKSg/OlwuXGQqKT8oPzpbZUVdWystXT9cZCspPykvLnNvdXJjZTsKICAgICAgdmFyIHBhdHRlcm5WZXJ0ZXggPSBuZXcgUmVnRXhwKCd2ZXJ0ZXgnICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0ICsgcGF0dGVybkZsb2F0LCAnZycpOwogICAgICB2YXIgcGF0dGVybk5vcm1hbCA9IG5ldyBSZWdFeHAoJ25vcm1hbCcgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQgKyBwYXR0ZXJuRmxvYXQsICdnJyk7CiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdOwogICAgICB2YXIgbm9ybWFscyA9IFtdOwogICAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTsKICAgICAgdmFyIHJlc3VsdDsKICAgICAgdmFyIGdyb3VwVmVydGV4ZXMgPSBbXTsKICAgICAgdmFyIGdyb3VwQ291bnQgPSAwOwogICAgICB2YXIgc3RhcnRWZXJ0ZXggPSAwOwogICAgICB2YXIgZW5kVmVydGV4ID0gMDsKCiAgICAgIHdoaWxlICgocmVzdWx0ID0gcGF0dGVyblNvbGlkLmV4ZWMoZGF0YSkpICE9PSBudWxsKSB7CiAgICAgICAgc3RhcnRWZXJ0ZXggPSBlbmRWZXJ0ZXg7CiAgICAgICAgdmFyIHNvbGlkID0gcmVzdWx0WzBdOwoKICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHBhdHRlcm5GYWNlLmV4ZWMoc29saWQpKSAhPT0gbnVsbCkgewogICAgICAgICAgdmFyIHZlcnRleENvdW50UGVyRmFjZSA9IDA7CiAgICAgICAgICB2YXIgbm9ybWFsQ291bnRQZXJGYWNlID0gMDsKICAgICAgICAgIHZhciB0ZXh0ID0gcmVzdWx0WzBdOwoKICAgICAgICAgIHdoaWxlICgocmVzdWx0ID0gcGF0dGVybk5vcm1hbC5leGVjKHRleHQpKSAhPT0gbnVsbCkgewogICAgICAgICAgICBub3JtYWwueCA9IHBhcnNlRmxvYXQocmVzdWx0WzFdKTsKICAgICAgICAgICAgbm9ybWFsLnkgPSBwYXJzZUZsb2F0KHJlc3VsdFsyXSk7CiAgICAgICAgICAgIG5vcm1hbC56ID0gcGFyc2VGbG9hdChyZXN1bHRbM10pOwogICAgICAgICAgICBub3JtYWxDb3VudFBlckZhY2UrKzsKICAgICAgICAgIH0KCiAgICAgICAgICB3aGlsZSAoKHJlc3VsdCA9IHBhdHRlcm5WZXJ0ZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHsKICAgICAgICAgICAgdmVydGljZXMucHVzaChwYXJzZUZsb2F0KHJlc3VsdFsxXSksIHBhcnNlRmxvYXQocmVzdWx0WzJdKSwgcGFyc2VGbG9hdChyZXN1bHRbM10pKTsKICAgICAgICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOwogICAgICAgICAgICB2ZXJ0ZXhDb3VudFBlckZhY2UrKzsKICAgICAgICAgICAgZW5kVmVydGV4Kys7CiAgICAgICAgICB9IC8vIGV2ZXJ5IGZhY2UgaGF2ZSB0byBvd24gT05FIHZhbGlkIG5vcm1hbAoKCiAgICAgICAgICBpZiAobm9ybWFsQ291bnRQZXJGYWNlICE9PSAxKSB7CiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNUTExvYWRlcjogU29tZXRoaW5nIGlzblwndCByaWdodCB3aXRoIHRoZSBub3JtYWwgb2YgZmFjZSBudW1iZXIgJyArIGZhY2VDb3VudGVyKTsKICAgICAgICAgIH0gLy8gZWFjaCBmYWNlIGhhdmUgdG8gb3duIFRIUkVFIHZhbGlkIHZlcnRpY2VzCgoKICAgICAgICAgIGlmICh2ZXJ0ZXhDb3VudFBlckZhY2UgIT09IDMpIHsKICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuU1RMTG9hZGVyOiBTb21ldGhpbmcgaXNuXCd0IHJpZ2h0IHdpdGggdGhlIHZlcnRpY2VzIG9mIGZhY2UgbnVtYmVyICcgKyBmYWNlQ291bnRlcik7CiAgICAgICAgICB9CgogICAgICAgICAgZmFjZUNvdW50ZXIrKzsKICAgICAgICB9CgogICAgICAgIGdyb3VwVmVydGV4ZXMucHVzaCh7CiAgICAgICAgICBzdGFydFZlcnRleDogc3RhcnRWZXJ0ZXgsCiAgICAgICAgICBlbmRWZXJ0ZXg6IGVuZFZlcnRleAogICAgICAgIH0pOwogICAgICAgIGdyb3VwQ291bnQrKzsKICAgICAgfQoKICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7CiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpOwoKICAgICAgaWYgKGdyb3VwQ291bnQgPiAwKSB7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cFZlcnRleGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBnZW9tZXRyeS5hZGRHcm91cChncm91cFZlcnRleGVzW2ldLnN0YXJ0VmVydGV4LCBncm91cFZlcnRleGVzW2ldLmVuZFZlcnRleCwgaSk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZ2VvbWV0cnk7CiAgICB9CgogICAgZnVuY3Rpb24gZW5zdXJlU3RyaW5nKGJ1ZmZlcikgewogICAgICBpZiAodHlwZW9mIGJ1ZmZlciAhPT0gJ3N0cmluZycpIHsKICAgICAgICByZXR1cm4gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShidWZmZXIpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIGJ1ZmZlcjsKICAgIH0KCiAgICBmdW5jdGlvbiBlbnN1cmVCaW5hcnkoYnVmZmVyKSB7CiAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgewogICAgICAgIHZhciBhcnJheV9idWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoKTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGFycmF5X2J1ZmZlcltpXSA9IGJ1ZmZlci5jaGFyQ29kZUF0KGkpICYgMHhmZjsgLy8gaW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW4KICAgICAgICB9CgogICAgICAgIHJldHVybiBhcnJheV9idWZmZXIuYnVmZmVyIHx8IGFycmF5X2J1ZmZlcjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYnVmZmVyOwogICAgICB9CiAgICB9IC8vIHN0YXJ0CgoKICAgIHZhciBiaW5EYXRhID0gZW5zdXJlQmluYXJ5KGRhdGEpOwogICAgcmV0dXJuIGlzQmluYXJ5KGJpbkRhdGEpID8gcGFyc2VCaW5hcnkoYmluRGF0YSkgOiBwYXJzZUFTQ0lJKGVuc3VyZVN0cmluZyhkYXRhKSk7CiAgfQp9KTsKZXhwb3J0IHsgU1RMTG9hZGVyIH07"},{"version":3,"sources":["E:/自己的项目/three_test/src/assets/jsm/loaders/STLLoader.js"],"names":["BufferAttribute","BufferGeometry","FileLoader","Float32BufferAttribute","Loader","LoaderUtils","Vector3","STLLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","text","parse","exception","data","isBinary","expect","face_size","n_faces","reader","DataView","getUint32","byteLength","solid","off","matchDataViewAt","query","offset","i","il","length","getUint8","parseBinary","faces","r","g","b","hasColors","colors","defaultR","defaultG","defaultB","alpha","index","Float32Array","dataOffset","faceLength","geometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","parseASCII","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","result","groupVertexes","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","console","error","addGroup","ensureString","buffer","decodeText","Uint8Array","ensureBinary","array_buffer","charCodeAt","binData"],"mappings":"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","sourcesContent":["/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n * @author neverhood311 / https://github.com/neverhood311\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * var mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  var materials = [];\n *  var nGeometryGroups = geometry.groups.length;\n *\n *  var colorMap = ...; // Some logic to index colors.\n *\n *  for (var i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tvar material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  var mesh = new THREE.Mesh(geometry, materials);\n */\n\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    FileLoader,\n    Float32BufferAttribute,\n    Loader,\n    LoaderUtils,\n    Vector3\n} from \"../../js/three.module.js\";\n\n\nvar STLLoader = function (manager) {\n\n    Loader.call(this, manager);\n\n};\n\nSTLLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n\n    constructor: STLLoader,\n\n    load: function (url, onLoad, onProgress, onError) {\n\n        var scope = this;\n\n        var loader = new FileLoader(scope.manager);\n        loader.setPath(scope.path);\n        loader.setResponseType('arraybuffer');\n        loader.load(url, function (text) {\n\n            try {\n\n                onLoad(scope.parse(text));\n\n            } catch (exception) {\n\n                if (onError) {\n\n                    onError(exception);\n\n                }\n\n            }\n\n        }, onProgress, onError);\n\n    },\n\n    parse: function (data) {\n\n        function isBinary(data) {\n\n            var expect, face_size, n_faces, reader;\n            reader = new DataView(data);\n            face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n            n_faces = reader.getUint32(80, true);\n            expect = 80 + (32 / 8) + (n_faces * face_size);\n\n            if (expect === reader.byteLength) {\n\n                return true;\n\n            }\n\n            // An ASCII STL data must begin with 'solid ' as the first six bytes.\n            // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n            // plentiful.  So, check the first 5 bytes for 'solid'.\n\n            // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n            // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n            // Search for \"solid\" to start anywhere after those prefixes.\n\n            // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n            var solid = [115, 111, 108, 105, 100];\n\n            for (var off = 0; off < 5; off++) {\n\n                // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n                if (matchDataViewAt(solid, reader, off)) return false;\n\n            }\n\n            // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n            return true;\n\n        }\n\n        function matchDataViewAt(query, reader, offset) {\n\n            // Check if each byte in query matches the corresponding byte from the current offset\n\n            for (var i = 0, il = query.length; i < il; i++) {\n\n                if (query[i] !== reader.getUint8(offset + i, false)) return false;\n\n            }\n\n            return true;\n\n        }\n\n        function parseBinary(data) {\n\n            var reader = new DataView(data);\n            var faces = reader.getUint32(80, true);\n\n            var r, g, b, hasColors = false, colors;\n            var defaultR, defaultG, defaultB, alpha;\n\n            // process STL header\n            // check for default color in header (\"COLOR=rgba\" sequence).\n\n            for (var index = 0; index < 80 - 10; index++) {\n\n                if ((reader.getUint32(index, false) == 0x434F4C4F /*COLO*/) &&\n                    (reader.getUint8(index + 4) == 0x52 /*'R'*/) &&\n                    (reader.getUint8(index + 5) == 0x3D /*'='*/)) {\n\n                    hasColors = true;\n                    colors = new Float32Array(faces * 3 * 3);\n\n                    defaultR = reader.getUint8(index + 6) / 255;\n                    defaultG = reader.getUint8(index + 7) / 255;\n                    defaultB = reader.getUint8(index + 8) / 255;\n                    alpha = reader.getUint8(index + 9) / 255;\n\n                }\n\n            }\n\n            var dataOffset = 84;\n            var faceLength = 12 * 4 + 2;\n\n            var geometry = new BufferGeometry();\n\n            var vertices = new Float32Array(faces * 3 * 3);\n            var normals = new Float32Array(faces * 3 * 3);\n\n            for (var face = 0; face < faces; face++) {\n\n                var start = dataOffset + face * faceLength;\n                var normalX = reader.getFloat32(start, true);\n                var normalY = reader.getFloat32(start + 4, true);\n                var normalZ = reader.getFloat32(start + 8, true);\n\n                if (hasColors) {\n\n                    var packedColor = reader.getUint16(start + 48, true);\n\n                    if ((packedColor & 0x8000) === 0) {\n\n                        // facet has its own unique color\n\n                        r = (packedColor & 0x1F) / 31;\n                        g = ((packedColor >> 5) & 0x1F) / 31;\n                        b = ((packedColor >> 10) & 0x1F) / 31;\n\n                    } else {\n\n                        r = defaultR;\n                        g = defaultG;\n                        b = defaultB;\n\n                    }\n\n                }\n\n                for (var i = 1; i <= 3; i++) {\n\n                    var vertexstart = start + i * 12;\n                    var componentIdx = (face * 3 * 3) + ((i - 1) * 3);\n\n                    vertices[componentIdx] = reader.getFloat32(vertexstart, true);\n                    vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\n                    vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\n\n                    normals[componentIdx] = normalX;\n                    normals[componentIdx + 1] = normalY;\n                    normals[componentIdx + 2] = normalZ;\n\n                    if (hasColors) {\n\n                        colors[componentIdx] = r;\n                        colors[componentIdx + 1] = g;\n                        colors[componentIdx + 2] = b;\n\n                    }\n\n                }\n\n            }\n\n            geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n            geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n\n            if (hasColors) {\n\n                geometry.setAttribute('color', new BufferAttribute(colors, 3));\n                geometry.hasColors = true;\n                geometry.alpha = alpha;\n\n            }\n\n            return geometry;\n\n        }\n\n        function parseASCII(data) {\n\n            var geometry = new BufferGeometry();\n            var patternSolid = /solid([\\s\\S]*?)endsolid/g;\n            var patternFace = /facet([\\s\\S]*?)endfacet/g;\n            var faceCounter = 0;\n\n            var patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n            var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n            var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n\n            var vertices = [];\n            var normals = [];\n\n            var normal = new Vector3();\n\n            var result;\n\n            var groupVertexes = [];\n            var groupCount = 0;\n            var startVertex = 0;\n            var endVertex = 0;\n\n            while ((result = patternSolid.exec(data)) !== null) {\n\n                startVertex = endVertex;\n\n                var solid = result[0];\n\n                while ((result = patternFace.exec(solid)) !== null) {\n\n                    var vertexCountPerFace = 0;\n                    var normalCountPerFace = 0;\n\n                    var text = result[0];\n\n                    while ((result = patternNormal.exec(text)) !== null) {\n\n                        normal.x = parseFloat(result[1]);\n                        normal.y = parseFloat(result[2]);\n                        normal.z = parseFloat(result[3]);\n                        normalCountPerFace++;\n\n                    }\n\n                    while ((result = patternVertex.exec(text)) !== null) {\n\n                        vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n                        normals.push(normal.x, normal.y, normal.z);\n                        vertexCountPerFace++;\n                        endVertex++;\n\n                    }\n\n                    // every face have to own ONE valid normal\n\n                    if (normalCountPerFace !== 1) {\n\n                        console.error('THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter);\n\n                    }\n\n                    // each face have to own THREE valid vertices\n\n                    if (vertexCountPerFace !== 3) {\n\n                        console.error('THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter);\n\n                    }\n\n                    faceCounter++;\n\n                }\n\n                groupVertexes.push({ startVertex: startVertex, endVertex: endVertex });\n                groupCount++;\n\n            }\n\n            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n            geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\n            if (groupCount > 0) {\n\n                for (var i = 0; i < groupVertexes.length; i++) {\n\n                    geometry.addGroup(groupVertexes[i].startVertex, groupVertexes[i].endVertex, i);\n\n                }\n\n            }\n\n            return geometry;\n\n        }\n\n        function ensureString(buffer) {\n\n            if (typeof buffer !== 'string') {\n\n                return LoaderUtils.decodeText(new Uint8Array(buffer));\n\n            }\n\n            return buffer;\n\n        }\n\n        function ensureBinary(buffer) {\n\n            if (typeof buffer === 'string') {\n\n                var array_buffer = new Uint8Array(buffer.length);\n                for (var i = 0; i < buffer.length; i++) {\n\n                    array_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n\n                }\n\n                return array_buffer.buffer || array_buffer;\n\n            } else {\n\n                return buffer;\n\n            }\n\n        }\n\n        // start\n\n        var binData = ensureBinary(data);\n\n        return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n\n    }\n\n});\n\nexport { STLLoader };\n"]}]}