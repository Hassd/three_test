{"remainingRequest":"E:\\自己的项目\\three_test\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!E:\\自己的项目\\three_test\\src\\views\\test\\text4.vue?vue&type=style&index=0&lang=less&","dependencies":[{"path":"E:\\自己的项目\\three_test\\src\\views\\test\\text4.vue","mtime":1581254657956},{"path":"E:\\自己的项目\\three_test\\node_modules\\css-loader\\index.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\less-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\@vue\\cli-plugin-babel\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"E:\\自己的项目\\three_test\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoNCi50ZXN0IHsNCiAgICB3aWR0aDogMTAwJTsNCiAgICBoZWlnaHQ6IDEwMCU7DQogICAgb3ZlcmZsb3c6IGhpZGRlbjsNCiAgICAuY29udGFpbmVyIHsNCiAgICAgICAgd2lkdGg6IDEwMCU7DQogICAgICAgIGhlaWdodDogMTAwJTsNCiAgICB9DQp9DQo="},{"version":3,"sources":["text4.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"text4.vue","sourceRoot":"src/views/test","sourcesContent":["<template>\r\n    <div class=\"test\">\r\n        <div class=\"container\" id=\"container\"></div>\r\n        <!-- <canvas id=\"canvas\"></canvas> -->\r\n    </div>\r\n</template>\r\n<script>\r\nimport * as THREE from \"@/assets/build/three.module\";\r\nimport { OrbitControls } from \"@/assets/examples/jsm/controls/OrbitControls\";\r\nimport { TWEEN } from \"@/assets/examples/jsm/libs/tween.module.min\";\r\nimport { ParametricGeometries } from \"@/assets/examples/jsm/geometries/ParametricGeometries\";\r\n\r\nimport mythree from \"@/service/three\";\r\n\r\nexport default {\r\n    data() {\r\n        return {\r\n            container: null,\r\n            renderer: null,\r\n            camera: null,\r\n            scene: null,\r\n            light: null,\r\n            controls: null,\r\n            raycaster: null,\r\n            mouse: null,\r\n            particleSystem: null\r\n        };\r\n    },\r\n    mounted() {\r\n        let three = new mythree();\r\n\r\n        console.log(three.version);\r\n\r\n        return;\r\n        if (document.getElementById(\"container\")) {\r\n            this.initRenderer();\r\n            this.initCamera();\r\n            this.initScene();\r\n            this.initLight();\r\n            this.initControls();\r\n            this.initRaycaster();\r\n            this.animate();\r\n            this.initGeometry();\r\n\r\n            window.addEventListener(\"resize\", this.onWindowResize, false);\r\n            window.addEventListener(\"click\", this.onclikc, false);\r\n        }\r\n    },\r\n    methods: {\r\n        initRenderer() {\r\n            this.container = document.getElementById(\"container\");\r\n            //渲染器\r\n            this.renderer = new THREE.WebGLRenderer({\r\n                antialias: true,\r\n                alpha: false\r\n            }); //alpha设置为true 背景为透明\r\n\r\n            this.renderer.setSize(\r\n                this.container.clientWidth,\r\n                this.container.clientHeight\r\n            );\r\n            // this.renderer.shadowMap.enabled = true;\r\n            this.container.appendChild(this.renderer.domElement);\r\n        },\r\n        initCamera() {\r\n            //相机\r\n            this.camera = new THREE.PerspectiveCamera(\r\n                75,\r\n                this.container.clientWidth / this.container.clientHeight,\r\n                1,\r\n                1000000\r\n            );\r\n            this.camera.position.x = 0;\r\n            this.camera.position.y = 0;\r\n            this.camera.position.z = 200;\r\n\r\n            this.camera.up.x = 0;\r\n            this.camera.up.y = 1;\r\n            this.camera.up.z = 0;\r\n\r\n            this.camera.lookAt(0, 0, 0);\r\n        },\r\n        initScene() {\r\n            //场景\r\n            this.scene = new THREE.Scene();\r\n        },\r\n        initLight() {\r\n            //光源\r\n            this.scene.add(new THREE.AmbientLight(0xffffff)); // 创建环境光源，不产生阴影\r\n            this.light = new THREE.DirectionalLight(0xffffff); // 创建点光源，可以产生阴影\r\n            this.light.position.set(0, 110, 110);\r\n            this.light.shadow.camera.top = 100;\r\n            this.light.shadow.camera.bottom = -100;\r\n            this.light.shadow.camera.left = -100;\r\n            this.light.shadow.camera.right = 100;\r\n            //告诉平行光需要开启阴影投射\r\n            this.light.castShadow = true;\r\n            this.scene.add(this.light);\r\n        },\r\n        initControls() {\r\n            //相机旋转插件\r\n            this.controls = new OrbitControls(\r\n                this.camera,\r\n                this.renderer.domElement\r\n            );\r\n            // 页面转动效果\r\n            // controls.enabled = false;\r\n            // 使动画循环使用时阻尼或自转 意思是否有惯性\r\n            this.controls.enableDamping = false;\r\n            //动态阻尼系数 就是鼠标拖拽旋转灵敏度\r\n            this.controls.dampingFactor = 1;\r\n            //是否可以缩放\r\n            this.controls.enableZoom = true;\r\n            //是否自动旋转\r\n            this.controls.autoRotate = false;\r\n            //设置相机距离原点的最远距离\r\n            this.controls.minDistance = 1;\r\n            //设置相机距离原点的最远距离\r\n            this.controls.maxDistance = 200000;\r\n            //是否开启右键拖拽\r\n            this.controls.enablePan = true;\r\n            //最大仰视角和俯视角\r\n            this.controls.minPolarAngle = 0; // radians\r\n            this.controls.maxPolarAngle = Math.PI;\r\n            //是否自动旋转，自动旋转速度。默认每秒30圈\r\n            this.controls.autoRotate = false;\r\n            this.controls.autoRotateSpeed = 0.2; // 30 seconds per round when fps is 60\r\n            //是否能使用键盘\r\n            this.controls.enableKeys = false;\r\n\r\n            // this.controls.target = new THREE.Vector3(17435, 2280, 13680); //修改相机原点\r\n        },\r\n        initRaycaster() {\r\n            //射线，用以判断点击那个模型(拾取)\r\n            this.raycaster = new THREE.Raycaster();\r\n            this.mouse = new THREE.Vector2();\r\n        },\r\n        onWindowResize() {\r\n            // 窗口自动适应\r\n            this.camera.aspect = window.innerWidth / window.innerHeight;\r\n            this.camera.updateProjectionMatrix();\r\n            this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n        },\r\n        animate() {\r\n            if (this.renderer) {\r\n                this.controls.update();\r\n                this.renderer.render(this.scene, this.camera);\r\n                TWEEN.update();\r\n                requestAnimationFrame(this.animate);\r\n            }\r\n        },\r\n        onclikc() {\r\n            //通过鼠标点击的位置计算出raycaster所需要的点的位置，以屏幕中心为原点，值的范围为-1到1.\r\n            let event = window.event;\r\n            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\r\n            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\r\n            // 通过鼠标点的位置和当前相机的矩阵计算出raycaster\r\n            this.raycaster.setFromCamera(this.mouse, this.camera);\r\n            var intersects = this.raycaster.intersectObjects(\r\n                this.scene.children,\r\n                true\r\n            );\r\n            if (intersects.length) {\r\n                // console.log(intersects[0]);\r\n                return;\r\n                // this.tween1();\r\n            }\r\n        },\r\n        initGeometry2() {\r\n            var geometry = new THREE.ParametricBufferGeometry(\r\n                ParametricGeometries.klein,\r\n                50,\r\n                50\r\n            );\r\n\r\n            let texture = new THREE.Texture(this.getCanvas());\r\n\r\n            var material = new THREE.MeshPhongMaterial({\r\n                map: texture\r\n            });\r\n            var klein = new THREE.Mesh(geometry, material);\r\n            // this.scene.add(klein);\r\n            klein.scale.set(10, 10, 10);\r\n            // let position = klein.geometry.attributes.position;\r\n            let _attributes = klein.geometry.attributes; //获取模型的点、面、线信息\r\n            let count = _attributes.position.count; //获取模型的点的个数\r\n            _attributes.positionEnd = _attributes.position.clone(); //复制点的信息，留着点最后的变换操作\r\n            _attributes.position1 = _attributes.position.clone(); //复制点的信息，留着点开始的变换操作\r\n            // let position = klein.geometry.attributes.position.clone();\r\n            // console.log(position.count);\r\n            // console.log(position);\r\n\r\n            let particleSystem = new THREE.Group(); // THREE.Group   和   THREE.Object3D()  差不多   性能要好一些\r\n\r\n            //先打乱点的位置先\r\n            for (let i = 0; i < count * 3; i++) {\r\n                _attributes.position.array[i] = Math.random() * 100 - 50;\r\n                _attributes.position1.array[i] = Math.random() * 100 - 50;\r\n            }\r\n\r\n            let particles = new THREE.Points(klein.geometry, material); //加入粒子系统中\r\n            particleSystem.add(particles);\r\n            this.scene.add(particleSystem);\r\n\r\n            return;\r\n\r\n            setTimeout(() => {\r\n                let pos = {\r\n                    val: 1\r\n                };\r\n                let tween1 = new TWEEN.Tween(pos);\r\n                tween1.to(\r\n                    {\r\n                        val: 0\r\n                    },\r\n                    2500\r\n                );\r\n                tween1.easing(TWEEN.Easing.Quadratic.InOut);\r\n                tween1.onUpdate(callback);\r\n                tween1.onComplete(function() {\r\n                    // console.log(\"过渡完成complete\");\r\n                });\r\n                let tween2 = new TWEEN.Tween(pos);\r\n                tween2.to(\r\n                    {\r\n                        val: 1\r\n                    },\r\n                    2500\r\n                );\r\n                tween2.easing(TWEEN.Easing.Quadratic.InOut);\r\n                tween2.onUpdate(callback);\r\n                tween2.onComplete(function() {\r\n                    // console.log(\"过渡完成complete\");\r\n                });\r\n\r\n                tween1.chain(tween2); //链式补间    在上一个补间结束的时候立即启动另外一个补间\r\n                tween2.chain(tween1);\r\n\r\n                tween1.start();\r\n                function callback(data) {\r\n                    let val = data.val;\r\n                    let particles = particleSystem.children;\r\n                    for (let i = 0; i < particles.length; i++) {\r\n                        let _attributes = particles[i].geometry.attributes;\r\n                        let positionEnd = _attributes.positionEnd.array;\r\n                        let position1 = _attributes.position1.array;\r\n                        let count = _attributes.position.count;\r\n                        for (let j = 0; j < count * 3; j++) {\r\n                            _attributes.position.array[j] =\r\n                                position1[j] * val + positionEnd[j] * (1 - val);\r\n                        }\r\n                        _attributes.position.needsUpdate = true; // 设置更新\r\n                    }\r\n                }\r\n            }, 2000);\r\n        },\r\n        initGeometry() {\r\n            var geometry = new THREE.BoxBufferGeometry(20, 20, 20, 20, 20, 20);\r\n            // var texture = new THREE.Texture(this.getCanvas());\r\n            // texture.needsUpdate = true;\r\n            // var material = new THREE.MeshBasicMaterial({\r\n            //     map: texture,\r\n            //     transparent: true\r\n            // });\r\n            // var cube = new THREE.Mesh(geometry, material);\r\n            // this.scene.add(cube);\r\n            // return;\r\n\r\n            var _attributes = geometry.attributes; //获取模型的点、面、线信息\r\n            var count = _attributes.position.count; //获取模型的点的个数\r\n            _attributes.positionEnd = _attributes.position.clone(); //复制点的信息，留着点最后的变换操作\r\n            _attributes.position1 = _attributes.position.clone(); //复制点的信息，留着点开始的变换操作\r\n\r\n            //先打乱点的位置先\r\n            for (let i = 0; i < count * 3; i++) {\r\n                _attributes.position.array[i] = Math.random() * 100 - 50;\r\n                _attributes.position1.array[i] = Math.random() * 100 - 50;\r\n            }\r\n\r\n            var texture = new THREE.Texture(this.getCanvas());\r\n            texture.needsUpdate = true;\r\n            var material = new THREE.PointsMaterial({\r\n                map: texture,\r\n                transparent: true\r\n            });\r\n            var particles = new THREE.Points(geometry, material); //加入粒子系统中\r\n            this.scene.add(particles);\r\n\r\n            setTimeout(() => {\r\n                let pos = {\r\n                    val: 1\r\n                };\r\n                let tween1 = new TWEEN.Tween(pos);\r\n                tween1.to(\r\n                    {\r\n                        val: 0\r\n                    },\r\n                    2500\r\n                );\r\n                tween1.easing(TWEEN.Easing.Quadratic.InOut);\r\n                tween1.onUpdate(callback);\r\n                tween1.onComplete(function() {\r\n                    // console.log(\"过渡完成complete\");\r\n                });\r\n                let tween2 = new TWEEN.Tween(pos);\r\n                tween2.to(\r\n                    {\r\n                        val: 1\r\n                    },\r\n                    2500\r\n                );\r\n                tween2.easing(TWEEN.Easing.Quadratic.InOut);\r\n                tween2.onUpdate(callback);\r\n                tween2.onComplete(function() {\r\n                    // console.log(\"过渡完成complete\");\r\n                });\r\n\r\n                tween1.chain(tween2); //链式补间    在上一个补间结束的时候立即启动另外一个补间\r\n                tween2.chain(tween1);\r\n\r\n                tween1.start();\r\n                function callback(data) {\r\n                    let val = data.val;\r\n                    let _attributes = particles.geometry.attributes;\r\n                    let positionEnd = _attributes.positionEnd.array;\r\n                    let position1 = _attributes.position1.array;\r\n                    let count = _attributes.position.count;\r\n                    for (let j = 0; j < count * 3; j++) {\r\n                        _attributes.position.array[j] =\r\n                            position1[j] * val + positionEnd[j] * (1 - val);\r\n                    }\r\n                    _attributes.position.needsUpdate = true; // 设置更新\r\n                }\r\n            }, 2000);\r\n        },\r\n        getCanvas() {\r\n            let canvas = document.createElement(\"canvas\");\r\n            // 开始绘制路径\r\n            canvas.width = 64;\r\n            canvas.height = 64;\r\n            let ctx = canvas.getContext(\"2d\");\r\n            ctx.beginPath();\r\n\r\n            ctx.arc(canvas.width / 2, canvas.height / 2, 32, 0, Math.PI * 2);\r\n\r\n            let gradient = ctx.createRadialGradient(\r\n                canvas.width / 2,\r\n                canvas.height / 2,\r\n                0,\r\n                canvas.width / 2,\r\n                canvas.height / 2,\r\n                canvas.width / 2\r\n            );\r\n            gradient.addColorStop(0, \"rgba(0,0,0,0)\");\r\n            gradient.addColorStop(0.005, \"rgba(255,255,255,1)\");\r\n            gradient.addColorStop(0.4, \"rgba(255,255,255,1)\");\r\n            gradient.addColorStop(1, \"rgba(0,0,0,0)\");\r\n\r\n            ctx.fillStyle = gradient;\r\n            ctx.fill();\r\n            // 绘制圆的路径**\r\n\r\n            // 0°是从三点钟方向开始的\r\n            // 描边路径\r\n            ctx.stroke();\r\n\r\n            return canvas;\r\n        }\r\n    }\r\n};\r\n</script>\r\n<style lang=\"less\">\r\n.test {\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    .container {\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n}\r\n</style>\r\n"]}]}